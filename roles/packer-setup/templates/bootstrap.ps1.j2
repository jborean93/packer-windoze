$ErrorActionPreference = 'Stop'
$tmp_dir = "$env:SystemDrive\temp"
$script_dir = Split-Path -Path $($script:MyInvocation.MyCommand.Path) -Parent

Function Write-Log($message, $level="INFO") {
    # Poor man's implementation of Log4Net
    $date_stamp = Get-Date -Format s
    $log_entry = "$date_stamp - $level - $message"
    $log_file = "$tmp_dir\bootstrap.log"
    Write-Host $log_entry
    Add-Content -Path $log_file -Value $log_entry
}

Function Reboot-AndResume($action) {
    # need to reboot the server and rerun this script at the next action
    $command = "$env:SystemDrive\Windows\System32\WindowsPowerShell\v1.0\powershell.exe $($script:MyInvocation.MyCommand.Path) '$action'"
    $reg_key = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
    $reg_property_name = "bootstrap"
    Set-ItemProperty -Path $reg_key -Name $reg_property_name -Value $command
    Write-Log -message "rebooting server and continuing bootstrap.ps1 with action '$action'"
    if (Get-Command -Name Restart-Computer -ErrorAction SilentlyContinue) {
        Restart-Computer -Force
        Start-Sleep -Seconds 10
    } else {
        # PS v1 (Server 2008) doesn't have the cmdlet Restart-Computer, use el-traditional
        shutdown /r /t 0
        Start-Sleep -Seconds 10
    }
}

Function Run-Process($executable, $arguments) {
    $process = New-Object -TypeName System.Diagnostics.Process
    $psi = $process.StartInfo
    $psi.FileName = $executable
    $psi.Arguments = $arguments
    Write-Log -message "starting new process '$executable $arguments'"
    $process.Start() | Out-Null

    $process.WaitForExit() | Out-Null
    $exit_code = $process.ExitCode
    Write-Log -message "process completed with exit code '$exit_code'"

    return $exit_code
}

Function Extract-Zip($zip, $dest) {
    Write-Log -message "extracting '$zip' to '$dest'"
    try {
        Add-Type -AssemblyName System.IO.Compression.FileSystem > $null
        $legacy = $false
    } catch {
        $legacy = $true
    }

    if ($legacy) {
        try {
            $shell = New-Object -ComObject Shell.Application
            $zip_src = $shell.NameSpace($zip)
            $zip_dest = $shell.NameSpace($dest)
            $zip_dest.CopyHere($zip_src.Items(), 1044)
        } catch {
            Write-Log -message "failed to extract zip file: $($_.Exception.Message)" -level "ERROR"
            throw $_
        }
    } else {
        try {
            [System.IO.Compression.ZipFile]::ExtractToDirectory($zip, $dest)
        } catch {
            Write-Log -message "failed to extract zip file: $($_.Exception.Message)" -level "ERROR"
            throw $_
        }
    }
}

Function Get-NetKVMDriverPath {
    $drive = (Get-PSDrive -PSProvider FileSystem).Name | Where-Object { Test-Path -LiteralPath "$($_):\NetKVM" }

    $host_key = "{{ pri_packer_setup_config.driver_host_string }}"
    $architecture = $env:PROCESSOR_ARCHITECTURE
    $inf_path = "$($drive):\NetKVM\$host_key\$architecture\netkvm.inf"
    return $inf_path
}

$action = $args[0]
if (-not (Test-Path -Path $tmp_dir)) {
    New-Item -Path $tmp_dir -ItemType Directory | Out-Null
}
Write-Log -message "starting bootstrap.ps1 with action '$action'"

$bootstrap_actions = @(
{% for action in pri_packer_setup_config.bootstrap_files %}
    @{
        name = "{{action.name}}"
        action = "{{action.action|default("install")}}"
        url = "{{action.url}}"
        file = "{{action.file|default()}}"
        zip_file_pattern = "{{action.zip_file_pattern|default()}}"
        arguments = "{{action.arguments|default("/quiet /norestart")}}"
    },
{% endfor %}
{% if opt_packer_setup_builder == 'virtualbox' %}
    @{
        name = "Red Hat Virtio Network Driver"
        path = Get-NetKVMDriverPath
        action = "driver"
    },
{% endif %}
    @{
        name = "Configure WinRM"
        action = "winrm"
    }
)

$actions = @()
if ($action) {
    $add_action = $false
    foreach ($bootstrap_action in $bootstrap_actions) {
        if ($bootstrap_action.name -eq $action) {
            $add_action = $true
        }

        if ($add_action) {
            $actions += $bootstrap_action
        }
    }
} else {
    $actions = $bootstrap_actions
}

for ($i = 0; $i -lt $actions.Count; $i++) {
    $current_action = $actions[$i]
    $next_action = $null
    if ($i -lt ($actions.Count - 1)) {
        $next_action = $actions[$i + 1]
    }

    switch($current_action.action) {
        "install" {
            Write-Log -message "Installing $($current_action.name)"
            if ($current_action.file) {
                $src = $current_action.file
            } else {
                $src = $current_action.url.Split("/")[-1]
            }
            $src = "$script_dir\$src"
            $exit_code = Run-Process -executable $src -arguments $current_action.arguments
            if ($exit_code -eq 3010) {
                Reboot-AndResume -action $next_action.name
            } elseif ($exit_code -ne 0) {
                $error_message = "failed to install $($current_action.name): exit code $exit_code"
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }
        }
        "install-zip" {
            Write-Log -message "Installing $($current_action.name)"
            if ($current_action.file) {
                $src = $current_action.file
            } else {
                $src = $current_action.url.Split("/")[-1]
            }
            $zip_src = "$script_dir\$src"
            Extract-Zip -zip $zip_src -dest $tmp_dir
            $install_file = Get-Item -Path "$tmp_dir\$($current_action.zip_file_pattern)"
            if ($install_file -eq $null) {
                $error_message = "unable to find extracted file of pattern $($current_action.zip_file_pattern) for installing $($current_action.name)"
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }

            $exit_code = Run-Process -executable $install_file -arguments $current_action.arguments
            if ($exit_code -eq 3010) {
                Reboot-AndResume -action $next_action.name
            } elseif ($exit_code -ne 0) {
                $error_message = "failed to install $($current_action.name): exit code $exit_code"
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }
        }
        "driver" {
            Write-Log -message "Installing driver $($current_action.name)"
            Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;

namespace PackerWindoze
{
    public class NativeMethods
    {
        [DllImport("Newdev.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool DiInstallDriverW(
            IntPtr hwndParent,
            string InfPath,
            UInt32 Flags,
            out bool NeedReboot);
    }
}
'@

            $sys_path = Get-ChildItem -Path (Split-Path -Path $current_action.path -Parent) -Filter "*.sys" -File
            $driver_cert = (Get-AuthenticodeSignature -LiteralPath $sys_path.FullName).SignerCertificate

            $trusted_certs = (Get-ChildItem -Path Cert:\LocalMachine\TrustedPublisher).Thumbprint
            if ($driver_cert.Thumbprint -notin $trusted_certs) {
                Write-Log -message "Certificate $($driver_cert.Thumbprint) not in TrustedPublisher store"
                $store_name = [System.Security.Cryptography.X509Certificates.StoreName]::TrustedPublisher
                $store_location = [System.Security.Cryptography.X509Certificates.Storelocation]::LocalMachine

                $store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
                $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)
                try {
                    $store.Add($driver_cert)
                } finally {
                    $store.Dispose()
                }
            }

            $needs_reboot = $false
            $res = [PackerWindoze.NativeMethods]::DiInstallDriverW([IntPtr]::Zero, $current_action.path, 0, [ref]$needs_reboot)
            if (-not $res) {
                $err = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                try {
                    throw [System.ComponentModel.Win32Exception]$err
                } catch [System.ComponentModel.Win32Exception] {
                    $error_msg = "failed to install driver $($current_action.name) - {0} (Win32 Error Code {1} - 0x{1:X8})" -f $_.Exception.Message, $err
                }
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }
            if ($needs_reboot) {
                Reboot-AndResume -action $next_action.name
            }
        }
        "winrm" {
            Write-Log -message "configuring WinRM listener to work over 5985 with Basic auth"
            &winrm.cmd quickconfig -q
            Set-Item -Path WSMan:\localhost\Service\Auth\Basic -Value $true
            Set-Item -Path WSMan:\localhost\Service\AllowUnencrypted -Value $true
            $winrm_service = Get-Service -Name winrm
            if ($winrm_service.Status -ne "Running") {
                try {
                    Start-Service -Name winrm
                } catch {
                    $error_message = "failed to start WinRM service required by Ansible"
                    Write-Log -message $error_message -level "ERROR"
                    throw $error_message
                }
            }

            Write-Log -message "enabling RDP"
            $rdp_wmi = Get-CimInstance -ClassName Win32_TerminalServiceSetting -Namespace root\CIMV2\TerminalServices
            $rdp_enable = $rdp_wmi | Invoke-CimMethod -MethodName SetAllowTSConnections -Arguments @{ AllowTSConnections = 1; ModifyFirewallException = 1 }
            if ($rdp_enable.ReturnValue -ne 0) {
                $error_message = "failed to change RDP connection settings, error code: $($rdp_enable.ReturnValue)"
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }

            Write-Log -message "enabling NLA authentication for RDP"
            $nla_wmi = Get-CimInstance -ClassName Win32_TSGeneralSetting -Namespace root\CIMV2\TerminalServices
            $nla_wmi | Invoke-CimMethod -MethodName SetUserAuthenticationRequired -Arguments @{ UserAuthenticationRequired = 1 } | Out-Null
            $nla_wmi = Get-CimInstance -ClassName Win32_TSGeneralSetting -Namespace root\CIMV2\TerminalServices
            if ($nla_wmi.UserAuthenticationRequired -ne 1) {
                $error_message = "failed to enable NLA"
                Write-Log -message $error_message -level "ERROR"
                throw $error_message
            }
        }
    }
}

Write-Log -message "bootstrap.ps1 complete"
